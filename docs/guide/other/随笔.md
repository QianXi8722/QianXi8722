
## 前端路由

::: tip
SPA：单页web应用
什么是前端路由

    保证只有一个html页面，且与用户交互时不刷新和跳转页面的同时，为SPA中的每个视图展示形式匹配一个特殊的url。
    为实现这一目标，需要做到以下两点：
    1.改变url，且不让浏览器向服务器发送请求
    2.可以监听url变化

hash模式和history模式就能实现上面的功能
:::
::: tip
hash模式

    hash就是指url后#号及以后的字符。比如 www.baidu.com/#hash。其中 “#hash”就是我们期望的hash
    hash值的变化，不会导致浏览器向服务器发送请求，且hash的改变会触发 hashchange事件，浏览器的前进和后退也对其进行控制
    
    window.location.hash = 'hash字符串'; // 用于设置 hash 值
    let hash = window.location.hash; // 获取当前 hash 值
    // 监听hash变化，点击浏览器的前进后退会触发
    window.addEventListener('hashchange', function(event){ 
        let newURL = event.newURL; // hash 改变后的新 url
        let oldURL = event.oldURL; // hash 改变前的旧 url
    },false)

:::
```js
// 创建一个路由对象，实现register方法用于注册每个hash值对应的回调函数
class HashRouter{
  constructor () {
    // 用于存储不同的hash值对应的回调函数
    this.routers = {};
  }
  // 用于注册每个视图
  register(hash, callback = function() {}){
    // 将注册页面的回调函数 存放至router中
    this.router[hash] = callback;
  }
  // 不存在hash值时，认为是首页，所以实现registerIndex 方法用于注册首页时
  // 的回调函数
  registerIndex(callback = function() {}){
    this.routers['index'] = callback;
  }
  // 用于处理视图未找到的情况
  registerNotFound(callback = function() {}) {
    this.routers['404'] = callback;
  }
  // 用于处理异常情况
  registerError(callback = function() {}) {
    this.routers['error'] = callback;
  }
  // 用户调用不同视图的回调函数
  load() {
    // 去掉hash中前面的#号
    let hash = location.hash.slice(1);
    let handler;
    // 判断是否存在hash, 没有则默认首页
    if(!hash) {
      handler = this.routers.index;
    } else if(!this.routers.hasOwnProperty(hash)) {
      // 未找到对应hash值
      handler = this.routers['404'] || function() {}
    } else{
      handler = this.routers[hash]
    }
    // 执行注册的回调函数
    try {
      handler.apply(this);
      // handler.call(this)
    }catch(e) {
      console.error(e);
      (this.routers['error'] || function(){}).call(this, e)
    }
  }
}



```
::: tip
history模式

在html5之前就有history对象。但在早期的history中多用于页面跳转：

    history.go(-1);       // 后退一页
    history.go(2);        // 前进两页
    history.forward();     // 前进一页
    history.back();      // 后退一页

:::

> HTML5引入了 history.pushState() 和 history.replaceState() 方法，
> 它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate 配合使用。

::: tip
history.pushState() 和 history.replaceState() 均接收三个参数（state, title, url）
参数说明如下：

    state：合法的 Javascript 对象，可以用在 popstate 事件中
    title：现在大多浏览器忽略这个参数，可以直接用 null 代替
    url：任意有效的 URL，用于更新浏览器的地址栏

history.pushState() 和 history.replaceState() 的区别在于：

    history.pushState() 在保留现有历史记录的同时，将 url 加入到历史记录中。
    history.replaceState() 会将历史记录中的当前页面历史替换为 url。

由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面，所以在 HTML5 中的 histroy 具备了实现前端路由的能力。

单页面对于 history模式而言，url的改变只能由四种方法引起

    1.点击浏览器前进 后退
    2.点击a链接
    3.在js代码中触发 history.pushState()
    4.在js代码中触发 history.replaceState()
::: 

```js
1. 创建一个路由对象，实现register方法用于注册每个location.pathname 值对应的回调函数
2. 当location.pathname === './'时, 认为是首页，所以实现registerIndex方法用于注册时的回调函数
3.解决location.path没有对应的匹配，增加方法registerNotFound用于注册默认回调函数
2.解决注册的回到函数执行时出现异常，增加方法rejisterError用于处理异常情况

class HistoryRouter{
  constructor() {
    // 用于存储不同path值对应的回调函数
    this.routers = {};
  }
  // 监听popstate
  listenPopState() {
    window.addEventListener('popstate', e=> {
      let state = e.state || {}
      let path = state.path || '';
      this.dealPathHandler(path)
    },false)
  }
  // 全局监听A链接
  listenLink() {
    window.addEventListener('click', e => {
      let dom = e.target;
      if(dom.tagName.toUpperCase() === 'A' && dom.getAttribute('href')) {
        // 阻止默认事件
        e.preventDefault()
        this.assign(dom.getAttribute('href'));
      }
    }, false)
  }
  // 用于注册每个视图
  register(path, callback = function() {}) {
    this.routers[path] = callback;
  }
  // 用于注册首页
  registerIndex(callback = function() {}) {
    this.routers['/'] = callback;
  }
  // 用于处理视图未找到的情况
  registerNotFound(callback = function(){}) {
    this.routers['404'] = callback;
  }
  // 用于处理异常情况
  registerError(callback = function() {}) {
    this.routers['error'] = callback;
  }
  // 跳转到path
  assign(path) {
    history.pushState({path}, null, path)
    this.dealPathHandler(path)
  }
  // 替换为path
  replace(path) {
    history.replaceState({path}, null,path);
    this.dealPathHandle(path)
  }
  // 通用处理 path 调用回调函数
  dealPathHandle(path) {
    let handler;
    // 没有对应path
    if(!this.routers.hasOwnProperty(path)) {
      handler = this.routes['404'] || function() {};
    } else {
      // 有对应path
      handler = this.routers[path];
    }
    try {
      handler.call(this)
    }catch(e) {
      console.error(e)
      (this.routers['error'] || function(){}).call(this, e)
    }

  }
}

```
::: tip
hash模式 和 history模式

  hash模式相对于 history模式的优点：

    兼容性好，可以兼容到IE8
    无需服务端配合处理非单页的url地址

  hash模式相对于 history模式的缺点：

    锚点功能失效
    相同hash值不会触发动作将记录加入到历史栈总，而pushState()可以
:::
